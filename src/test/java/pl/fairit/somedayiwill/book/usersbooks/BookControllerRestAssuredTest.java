package pl.fairit.somedayiwill.book.usersbooks;

import io.restassured.http.ContentType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.restdocs.RestDocumentationExtension;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import pl.fairit.somedayiwill.book.testbooks.TestBookDto;
import pl.fairit.somedayiwill.newsletter.SendGridEmailService;
import pl.fairit.somedayiwill.security.TestAuthRequest;
import pl.fairit.somedayiwill.user.TestUsers;

import java.util.Objects;

import static io.restassured.RestAssured.given;
import static java.util.Objects.nonNull;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static pl.fairit.somedayiwill.security.TestAuthRequest.retrieveLoginRequestBodyFromProvidedAppUser;
import static pl.fairit.somedayiwill.security.TestAuthRequest.retrieveSignupRequestBodyFromProvidedAppUser;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT, value = "server.port=8087")
@ExtendWith({RestDocumentationExtension.class, SpringExtension.class})
@MockBean(SendGridEmailService.class)
@ContextConfiguration
class BookControllerRestAssuredTest {
    @LocalServerPort
    private int port;
    private static String token;

    @BeforeEach
    public void authorization() {
        if (nonNull(token)) {
            return;
        }
        var user = TestUsers.aUserWithRandomCredentials();
        var signupRequest = retrieveSignupRequestBodyFromProvidedAppUser(user);
        var loginRequest = retrieveLoginRequestBodyFromProvidedAppUser(user);
        given()
                .port(port)
                .basePath("/auth/signup")
                .contentType(ContentType.JSON)
                .body(signupRequest)
                .post();

        var authResponse = given()
                .port(port)
                .basePath("/auth/login")
                .contentType(ContentType.JSON)
                .body(loginRequest)
                .post()
                .then()
                .extract()
                .body()
                .asString();

        token = Objects.requireNonNull(TestAuthRequest.getTokenFromJSONString(authResponse)).getAccessToken();
    }

    @Test
    public void shouldReturnUnauthorizedWhenGetWithNoTokePerformed() {
        //@formatter:off
        given()
                .port(port)
                .basePath("/users/me/books")
        .when()
                .get()
        .then()
                .assertThat()
                .statusCode(401);
        //@formatter:on
    }

    @Test
    public void shouldReturnListOfUsersBooksWhenGetAllPerformed() {
        var response = given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .get();
        var responseBody = response.getBody().asString();

        assertTrue(responseBody.contains("books"));
        assertEquals(200, response.getStatusCode());
    }

    @Test
    public void shouldReturnSavedBookWhenPostPerformed() {
        var bookToSave = TestBookDto.aRandomBookDto();
        var jsonBookDto = TestBookDto.asJSONString(bookToSave);

        var response = given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .contentType(ContentType.JSON)
                .body(jsonBookDto)
                .post();
        var returnedBookDto = TestBookDto.fromJSONString(response.getBody().asString());
        bookToSave.setId(returnedBookDto.getId());
                    /*BookId is generated by database so there will always be this small difference
                    between object before and after save. That's why I'm setting here id manually
                    to make this test possible to pass.*/

        assertEquals(bookToSave, returnedBookDto);
        assertEquals(201, response.getStatusCode());
    }

    @Test
    public void shouldReturnBookWhenGetBookByIdPerformed() {
        var bookToSave = TestBookDto.aRandomBookDto();
        var jsonBookDto = TestBookDto.asJSONString(bookToSave);

        //save book
        var postResponse = given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .contentType(ContentType.JSON)
                .body(jsonBookDto)
                .post();
        bookToSave = TestBookDto.fromJSONString(postResponse.getBody().asString());
        //get book
        var getResponse = given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .contentType(ContentType.JSON)
                .get("/" + bookToSave.getId());
        var returnedBook = TestBookDto.fromJSONString(getResponse.getBody().asString());

        assertEquals(bookToSave, returnedBook);
        assertEquals(200, getResponse.getStatusCode());
    }

    @Test
    public void shouldReturnNoContentStatusCodeAfterDeleteOnePerformed() {
        var bookToSave = TestBookDto.aRandomBookDto();
        var jsonBookDto = TestBookDto.asJSONString(bookToSave);

        //@formatter:off
        //save book
        var postResponse = given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .contentType(ContentType.JSON)
                .body(jsonBookDto)
                .post();
        bookToSave = TestBookDto.fromJSONString(postResponse.getBody().asString());
        //delete book
        assert bookToSave != null;
        given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .contentType(ContentType.JSON)
        .when()
                .delete("/" + bookToSave.getId())
        .then()
                .statusCode(204);
        //attempt to get deleted book
        var getResponse = given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .contentType(ContentType.JSON)
        .when()
                .get("/" + bookToSave.getId())
        .then()
                .assertThat()
                .statusCode(404)
                .and()
                .extract()
                .body()
                .asString();
        //@formatter:on

        assertTrue(getResponse.contains("Book with given id does not exist"));
    }

    @Test //todo: assert empty array returned
    public void shouldReturnedNoContentWhenDeleteAllBooksPerformed() {
        given()
                .port(port)
                .basePath("/users/me/books")
                .header("Authorization", "Bearer " + token)
                .contentType(ContentType.JSON)
                .when()
                .delete()
                .then()
                .assertThat()
                .statusCode(204);
    }
}

